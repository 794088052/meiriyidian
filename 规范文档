05
G.EDV.05 防止解析来自外部的XML导致的外部实体（XML External Entity）攻 击 【级别】 要求 【描述】 XML实体包括内部实体和外部实体。外部实体格式： 或者 。Java中引入外部实体的协议包括http、https、 ftp、file、jar、netdoc、mailto等。XXE漏洞发生在应用程序解析来自外部的XML数据或文件时没有禁 止外部实体的加载，造成任意文件读取、内网端口扫描、内网网站攻击、DoS攻击等危害。以下为两个 具体的外部实体攻击利用示例： 1.利用外部实体的引用功能实现任意文件的读取： 2.使用参数实体和避免XML解析语法错误，构造恶意的实体解析： XML文件：构造参数实体 % start；% goodies；% end；% dtd定义一个恶意的combine.dtd joe</id><role>Administrator</role><!-- operator --><description>I want to be an administrator private void createXMLStream(BufferedOutputStream outStream, User user) throws IOException { ... String encodeUserId = HWEncoder.encodeForXML(user.getUserId()); String encodeDec = HWEncoder.encodeForXML(user.getDescription()); String xmlString = "" + encodeUserId + "operator" + encodeDec + ""; outStream.write(xmlString.getBytes(StandardCharsets.UTF_8)); outStream.flush(); } ]> Joe &file; ... 华为资产，仅供 zWX5326983 本人使用 华为资产，仅供 zWX5326983 本人使用 恶意DTD：combine.dtd中定义实体&all; 甚至可以这样构造恶意的combine.dtd，将结果发送到目标地址，最后会获得file:///etc/fstab文件。 【反例】 上述示例中，解析XML文件时未进行安全防护，当解析的XML文件是恶意用户精心构造的，系统会受到 XXE攻击。 【正例】（禁止解析DTDs） 上述示例中，设置禁止解析DTDs的属性，有效避免了利用XML实体进行的各种攻击。 【正例】（禁止解析外部一般实体和外部参数实体） %dtd; ]> &all; %send; private void parseXmlFile(String filePath) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new File(filePath)); ... // 解析xml文件中的内容 } catch (ParserConfigurationException ex) { // 处理异常 } ... } private void parserXmlFileDisableDtds(String filePath) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); dbf.setFeature("http://xml.org/sax/features/external-general-entities", false); dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new File(filePath)); ... // 解析xml文件中的内容 } catch (ParserConfigurationException ex) { // 处理异常 } ... } 华为资产，仅供 zWX5326983 本人使用 华为资产，仅供 zWX5326983 本人使用 上述示例中，设置了禁止解析外部实体的属性，能防止外部实体（XXE）攻击，但不能防止XML内部实 体类攻击。 【正例】（对外部实体进行白名单校验） 上述示例中，定义一个CustomResolver类来实现接口 org.xml.sax.EntityResolver ，在这个类中实 现自定义的处理外部实体机制。使用白名单机制对外部实体进行校验，当外部实体在白名单范围内时正 常访问实体，否则返回一个空的实体内容。 当系统中涉及的XML操作中必须使用外部实体时，必须对外部实体进行白名单校验。具体的校验方式如 上述代码，自定义一个 ValidateEntityResolver 类（实现接口 org.xml.sax.EntityResolver ）， 在 resolveEntity 方法中对XML中引入的实体进行白名单校验，拒绝解析非白名单中的外部实体。 说明：XML解析器种类较多，规范不能一一列举。当程序涉及到外部XML数据的解析操作时，可参考正 例中的配置项进行防护，并充分验证防护配置是否能正常生效。其他解析器如何防护XXE示例请参考 《XXE攻击漏洞共性问题排查指导V1.2》文档。 【例外】 private void parserXmlFileDisableExternalEntityes(String filePath) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false); dbf.setFeature("http://xml.org/sax/features/external-general-entities", false); dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new File(filePath)); ... // 解析xml文件中的内容 } catch (ParserConfigurationException ex) { // 处理异常 } ... } private static void parserXmlFileValidateEntities(String filePath) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); db.setEntityResolver(new ValidateEntityResolver()); Document doc = db.parse(new File(filePath)); ... // 解析xml文件中的内容 } catch (ParserConfigurationException ex) { // 处理异常 } ... } class ValidateEntityResolver implements EntityResolver { private static final String GOOD_ENTITY = "file:/Users/onlinestore/good.xml"; public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException { if (publicId != null && publicId.equals(GOOD_ENTITY)) { return new InputSource(publicId); } else if (systemId != null && systemId.equals(GOOD_ENTITY)) { return new InputSource(systemId); } else { return new InputSource(); } } } 华为资产，仅供 zWX5326983 本人使用 华为资产，仅供 zWX5326983 本人使用 Android的SDK中，原生XML解析器在解析XML时不涉及实体解析，不需要进行特殊防护。


06 
G.EDV.06 防止解析来自外部的XML导致的内部实体扩展（XML Entity Expansion）攻击 【级别】 要求 【描述】 XML内部实体格式： 。内部实体攻击比较常见的是XML Entity Expansion攻击，它主要试图通过消耗目标程序的服务器内存资源导致DoS攻击。例如，解析下面的 XML时，因为内部实体lol9是一个非常大的字符串，所以解析 节点时，会占用大量服务器内存 资源，导致拒绝服务攻击。 内部实体扩展攻击最好的防护措施是禁止DTDs的解析，如果必须使用内部实体时，也可以对内部实体 数量进行限制，以消减内部实体扩展攻击发生的可能性。 【正例】（禁止解析DTDs） 【正例】（通过系统属性限制实体数量） 上述示例中，通过设置系统属性限制解析实体数量不超过200。 备注：系统属性 entityExpansionLimit 在JDK 7u45+、JDK 8版本中支持。JAXP中的SAX和StAX类型 解析器同样生效。 ]> &lol9; public void receiveXMLStream(InputStream inStream) throws ParserConfigurationException, SAXException, IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); dbf.setFeature("http://xml.org/sax/features/external-general-entities", false); dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false); DocumentBuilder db = dbf.newDocumentBuilder(); db.parse(inStream); } public void receiveXMLStream(InputStream inStream) throws ParserConfigurationException, SAXException, IOException { // 使用系统属性限制 System.setProperty("entityExpansionLimit", "200"); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); db.parse(inStream); } 华为资产，仅供 zWX5326983 本人使用 华为资产，仅供 zWX5326983 本人使用 【正例】（限制实体数量） Java中的JAXP解析器默认限制实体解析数量是64,000个，但通常不会需要解析这么多的实体，可以进一 步限制实体数量。上述示例中，通过设置DOM解析器的属性限制解析的内部实体数量上限为200。 备注：属性 http://www.oracle.com/xml/jaxp/properties/entityExpansionLimit 在JDK 7u45+、JDK 8版本中支持。JAXP中的SAX和StAX类型解析器不支持该属性。 说明：XML解析器种类较多，规范不能一一列举。当程序涉及到外部XML数据的解析操作时，可参考正 例中的配置项进行防护，并充分验证防护配置是否能正常生效。 【例外】 Android的SDK中，原生XML解析器在解析XML时不涉及实体解析，不需要进行特殊防护。


G.EDV.07 禁止使用不安全的XSLT转换XML文件 【级别】 要求 【描述】 XSLT是一种样式转换标记语言，可以将XML数据转换为另外的XML或其他格式，如HTML网页，纯文 字。因为XSLT的功能十分强大，可以导致任意代码执行，当使用TransformerFactory转换XML格式数 据的时候，需要添加安全策略禁止不安全的XSLT代码执行。 【反例】 上述示例中，xslt没有做任何限制，直接调用，当执行类似如下XSLT代码的时候，会导致命令执行漏 洞： public void receiveXMLStream(InputStream inStream) throws ParserConfigurationException, SAXException, IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setAttribute("http://www.oracle.com/xml/jaxp/properties/entityExpansionLimit", "200"); DocumentBuilder db = dbf.newDocumentBuilder(); db.parse(inStream); } public void XsltTrans(String src, String dst, String xslt) { // 获取转换器工厂 TransformerFactory tf = TransformerFactory.newInstance(); try { // 获取转换器对象实例 Transformer transformer = tf.newTransformer(new StreamSource(xslt)); // 进行转换 transformer.transform(new StreamSource(src), new StreamResult(new FileOutputStream(dst))); ... } catch (TransformerException ex) { // 处理异常 } ... } 华为资产，仅供 zWX5326983 本人使用 华为资产，仅供 zWX5326983 本人使用 【正例】 上述示例中，在TransformerFactory中开启了安全防护策略。Java对xslt内置了黑名单，通过将 http://javax.xml.XMLConstants/feature/secure-processing 属性设置为true开启防护，可以禁 用一些不安全的方法。 G.EDV.08 正则表达式要尽量简单，防止ReDos攻击 【级别】 要求 【描述】 ReDos攻击是正则编写不当导致的常见安全风险。Java中的正则匹配使用的是NFA引擎。NFA引擎的回 溯机制，导致当字符串文本与正则表达式不匹配时，所花费的时间要比匹配时多，即要确定匹配失败， 需要与所有可能的路径进行对比匹配，证明都不匹配时，才返回匹配失败。当使用简单的非分组正则表 达式时，一般不会存在ReDos攻击。容易存在ReDos攻击的正则表达式主要有两类： 1、 包含具有自我重复的重复性分组的正则，例如： ^(\d+)+$ ^(\d*)*$ ^(\d+)*$ ^(\d+|\s+)*$ 2、 包含替换的重复性分组，例如： ^(\d|\d|\d)+$ ^(\d|\d?)+$ 对于ReDos攻击的防护手段主要包括： public void xsltTrans(String src, String dst, String xslt) { // 获取转换器工厂 TransformerFactory tf = TransformerFactory.newInstance(); try { // 转换器工厂设置黑名单，禁用一些不安全的方法，类似XXE防护 tf.setFeature("http://javax.xml.XMLConstants/feature/secure-processing", true); // 获取转换器对象实例 Transformer transformer = tf.newTransformer(new StreamSource(xslt)); // 去掉 transformer.setOutputProperty("omit-xml-declaration", "yes"); // 进行转换 transformer.transform(new StreamSource(src), new StreamResult(new FileOutputStream(dst))); ... } catch (TransformerException ex) { // 处理异常 } ... } 华为资产，仅供 zWX5326983 本人使用 华为资产，仅供 zWX5326983 本人使用 进行正则匹配前，先对匹配的文本的长度进行校验； 在编写正则时，尽量不要使用过于复杂的正则，尽量少用分组，例如对于正则 ^(([a-z])+\.)+[AZ]([a-z])+$ （存在ReDos风险），可以将多余的分组删除： ^([a-z]+\.)+[A-Z][a-z]+$ ，这样 在不改变检查规则的前提下消除了ReDos风险； 避免动态构建正则，当使用外部数据构造正则时，要使用白名单进行严格校验。 【反例】 上述示例中，正则表达式 a(b|c+)+d 存在ReDos风险，当匹配的字符串格式类 似"accccccccccccccccx"时，随中间的字符"c"的增加，代码执行时间将成指数级增长。 【正例】 上述示例中，将正则表达式精简为 a[bc]+d 。与 a(b|c+)+d 相比，可以在实现相同功能的前提下消除 ReDos风险。 【反例】 上述示例中，使用外部指定的keyword构造正则，当外部输入中使用了重复性分组，可能会导致最终的 正则存在ReDos风险。在实际开发代码过程中，应避免直接使用外部数据构造正则或直接使用外部数据 作为正则使用。 G.EDV.09 禁止直接使用外部数据作为反射操作中的类名/方法名 【级别】 要求 【描述】 private static final Pattern REGEX_PATTER = Pattern.compile("a(b|c+)+d"); public static void main(String[] args) { ... Matcher matcher = REGEX_PATTER.matcher(args[0]); if (matcher.matches()) { ... } else { ... } ... } private static final Pattern REGEX_PATTER = Pattern.compile("a[bc]+d"); public static void main(String[] args) { ... Matcher matcher = REGEX_PATTER.matcher(args[0]); if (matcher.matches()) { ... } else { ... } ... } String key = request.getParameter("keyword"); ... String regex = "[a-zA-Z0-9_-]+@" + key + "\\.com"; Pattern searchPattern = Pattern.compile(regex); ... 华为资产，仅供 zWX5326983 本人使用 华为资产，仅供 zWX5326983 本人使用 反射操作中直接使用外部数据作为类名或方法名，会导致系统执行非预期的逻辑流程（Unsafe Reflection）。这可被恶意用户利用来绕过安全检查或执行任意代码。当反射操作需要使用外部数据 时，必须对外部数据进行白名单校验，明确允许访问的类或方法列表；另外也可以通过让用户在指定范 围内选择的方式进行防护。 【反例】 上述示例中，直接使用外部指定的类名通过反射构造了一个对象，恶意用户可利用此处构造一个任意的 BaseClass 子类的对象，当恶意用户可控制 BaseClass 的某个子类时，则可在该子类的 doSomething() 方法中执行任意代码。另外恶意用户还可以利用此代码执行任意类的默认构造方法， 即使在进行类型转换时抛出 ClassCastException ，恶意用户预期的构造方法中的代码也已经执行。 【正例】 上述示例中，外部只能指定要反射的类的代号，当代号可映射为一个指定的类名时，执行反射操作，否 则判断为非法参数。这样可以有效限制反射操作的类的范围。
